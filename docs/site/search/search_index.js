var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"Welcome to the OCTproZ v1.8.0 User Manual! <p>Date: April 27, 2025 \u2003 Author: Miroslav Zabic (zabicmagic@spectralcode.de)</p>"},{"location":"index.html#about","title":"About","text":"<p>OCTproZ is an open source and cross-platform software for optical coherence tomography (OCT) processing and visualization. A plugin system enables the integration of custom OCT systems and software modules. You can find the most recent software release on the GitHub project page.</p>"},{"location":"index.html#user-guide","title":"User Guide","text":"<p>This is the user guide for OCTproZ. Browse by categories on the left, or if you are looking for a specific topic, use the search bar at the top of the page.</p> <p>Just like OCTproZ itself, this user guide is an ongoing project that undergoes continuous change. If you spot incomplete or incorrect information, feel free to email me or open an issue on the project page on GitHub.</p>"},{"location":"faq.html","title":"FAQ","text":""},{"location":"faq.html#which-oct-raw-data-format-is-supported-by-the-virtual-oct-system","title":"Which OCT raw data format is supported by the Virtual OCT System?","text":"<p>Raw data files that only contain the raw data are supported. The samples in the raw file must have a bit depth between 8 bits and 32 bits, the byte order must be little-endian and the raw data must be unpacked. For example, raw data with packed 12-bit samples (data for two samples is spread over 3 bytes) is currently not supported.</p> <p>If you have any questions, feel free to contact me: zabicmagic@spectralcode.de</p>"},{"location":"functionality.html","title":"Core Functionality","text":"<p>This section explains the core functionality accessible through the GUI, excluding any plugin features.</p>"},{"location":"functionality.html#overview-of-the-graphical-user-interface","title":"Overview of the graphical user interface","text":"Overview of the main GUI elements of OCTproZ <ul> <li>Menu Bar: Contains the menus <code>File</code>, <code>View</code>, <code>Extras</code>, and <code>Help</code>. Plugins can be accessed through <code>Extras \u2192 Extension</code>.</li> <li>Toolbar: Provides direct access to frequently used functionalities, such as opening output windows, displaying the messaging console, and enabling/disabling the orientation marker within the B-scan and en face view.</li> <li>Sidebar: This is the central control interface. At the top, it contains the Start Acquisition, Stop Acquisition, Start Recording, Connect OCT System, and OCT System Settings buttons. The sidebar also includes the Processing and Recording tabs, as well as additional plugin-related tabs (if activated). At the bottom, it features an information area that displays current acquisition speed.</li> <li>Messaging Console: Displays info and error messages.</li> <li>Output Windows:  Includes 1D, B-scan, en face view, and volume windows, which can be enabled through the toolbar or the <code>View</code> menu in the menu bar. </li> </ul>"},{"location":"functionality.html#processing-tab","title":"Processing tab","text":"<p>The processing tab in the sidebar allows you to control all signal processing settings. For an in-depth explanation of each processing step, refer to the processing section. Below is a brief description of each parameter available in the processing tab:</p> Parameter Description Bit shift raw sample values by 4 Divides each raw sample value by 16 (for digitizers storing 12-bit samples in 16-bit words). Sinusoidal scan correction Corrects distortions from sinusoidal scanning motion via linear interpolation. Flip every second B-scan Unflips every second B-scan in bidirectional scanning schemes. Rolling average background removal Removes the DC background using a rolling average filter. Window size Number of samples used for rolling average background removal. k-linearization Resamples raw data for uniform k-space sampling. Interpolation Method used for resampling during k-linearization (Linear, Cubic Spline, Lanczos). c<sub>0</sub> to c<sub>3</sub> Coefficients for resampling curve polynomial used for k-linearization. Dispersion compensation Numerically compensates for dispersion mismatch between OCT sample and reference arms. d<sub>0</sub> to d<sub>3</sub> Coefficients for dispersion compensation phase function. d<sub>0</sub>: no effect, d<sub>1</sub>, shifts OCT image axially, d<sub>2</sub> and d<sub>3</sub>: affect axial resolution Windowing Applies a window function to reduce side lobes in the IFFT result. Window Type Selects the window function type (Gaussian, Hann, Sine, Lanczos, Rectangular). Fill Factor Controls the width of the window function. Center Position Defines the center of the window function. Typically set to 0.5, but can be adjusted (especially with a narrow window width) to select a specific spectral range for OCT processing. Fixed-pattern noise removal Removes structural artifacts (static horizontal lines). B-scans for noise determination Number of B-scans used to determine the fixed-pattern noise profile. Log scaling Applies logarithmic scaling. Max value Sets the upper limit for grayscale scaling (in dB if log scaling is enabled; linear otherwise). Min value Sets the lower limit for grayscale scaling. (in dB if log scaling is enabled; linear otherwise). Multiplicator Adjusts image contrast in grayscale conversion. Typically this is set to 1.0. Offset Adjusts image brightness in grayscale conversion. Typically this is set to 0.0. Post processing background removal Subtracts a pre-recorded background A-scan to reduce static artifacts that are not removed by DC background removal and fixed pattern noise removal. Weight Scaling factor for background subtraction."},{"location":"functionality.html#loading-custom-resampling-curves","title":"Loading custom resampling curves","text":"<p>There are two ways to load a custom resampling curve for k-linearization:</p> <ol> <li> <p>Use the menu bar:    Navigate to <code>Extras \u2192 Resampling curve for k-linearization \u2192 Load custom curve from file...</code>.</p> </li> <li> <p>Use right-click in the sidebar:    Right-click anywhere within the k-linearization group box, outside the plot area, to open a context menu. For example, right-clicking in the empty area next to the Interpolation drop-down menu to access the option for loading a custom resampling curve.</p> </li> </ol>"},{"location":"functionality.html#recording-tab","title":"Recording tab","text":"<p>The Recording tab in the sidebar allows you to configure recording settings.</p> <p>Before pressing the Record button, you must configure these settings\u2014especially the recording path. If the recording path is not set, recording will not occur, and you will receive an error message in the message console.</p> <p>The configured settings are applied to all recordings. Each recorded file will be automatically named using the following format:</p> <pre><code>yyyyMMdd_hhmmsszzz_&lt;yourfilename&gt;_&lt;processed|raw&gt;.raw\n</code></pre>"},{"location":"functionality.html#filename-breakdown","title":"Filename breakdown","text":"<ul> <li><code>yyyy</code> = Year (4 digits)  </li> <li><code>MM</code> = Month (2 digits)  </li> <li><code>dd</code> = Day (2 digits)  </li> <li><code>hh</code> = Hour (2 digits, 24-hour format)  </li> <li><code>mm</code> = Minute (2 digits)  </li> <li><code>ss</code> = Second (2 digits)  </li> <li><code>zzz</code> = Milliseconds (3 digits)  </li> <li><code>&lt;yourfilename&gt;</code> = The custom filename you provide in the recording settings  </li> <li><code>&lt;processed|raw&gt;</code> = Indicates whether the recording is processed or raw data  </li> <li><code>.raw</code> = The file extension (recording is saved as a raw binary file)</li> </ul> <p>Example filename:</p> <pre><code>20250427_153045123_apple1_processed.raw\n</code></pre> <p>In this example:</p> <ul> <li>The recording was made on April 27, 2025, at 15:30:45.123 (3:30 PM and 45.123 seconds).</li> <li>The user-provided filename was apple1.</li> <li>The file contains processed data.</li> </ul> <p>You also have the option to set a description text, which is saved in a meta file alongside the recording (if save meta information is enabled). The meta file contains all the processing and recording settings used at the time of recording. This meta file is the same as the settings file that can be saved and loaded through the menu bar (see section Saving and loading settings).</p>"},{"location":"functionality.html#recording-parameter","title":"Recording parameter","text":"<p>Below is a brief description of each parameter available in the recording tab:</p> Parameter Description Recordings folder Sets the destination folder where recordings are saved. Screenshots Enables saving of screenshots of the currently visible output windows (B-scan, en face view, volume) during recording. Raw buffers Enables recording of raw spectral buffers. Processed buffers Enables recording of processed data buffers. Recording name Specifies the name of the recording session. This name will be included as part of the file name. Description Adds a text description that is saved in the meta file. Start recording with first buffer of volume Starts recording with the first buffer of a volume. This is only useful if you have multiple buffers per volume and want to guarantee that recording begins with the first buffer of the volume, rather than the buffer that is currently being acquired when the record button is pressed. Stop acquisition after record Stops data acquisition and processing automatically after the recording is complete. Save meta information Saves additional meta information alongside recorded data. Same as <code>File \u2192 Save Settings to File</code>. Save processed buffers as 32-bit float Saves processed data buffers in 32-bit floating-point format. If disabled, the data will be saved using the same bit depth as the input raw data. Buffers to record Sets the number of buffers to record."},{"location":"functionality.html#scheduled-recording","title":"Scheduled recording","text":"<p>The Recording Scheduler (screenshot below) is available under <code>Extras \u2192 Scheduled Recording</code>. It allows you to automatically perform recordings at defined intervals, useful for generating time-series. </p> Recording Scheduler Interface <p>Note</p> <p>Ensure the interval between recordings is longer than the total time needed for a single recording (data acquisition + saving to disk). Overlapping recordings are not possible. If a recording takes longer than the defined interval a warning is shown, and the scheduler will retry after a 10-second delay.</p> Parameter Description Start first recording in Time delay before the first recording starts after clicking Start Schedule (format: hh:mm:ss). Wait between recordings Interval between the start times of consecutive recordings (format: hh:mm:ss). Total recordings Total number of recordings to perform in the scheduled task."},{"location":"functionality.html#saving-and-loading-settings","title":"Saving and loading settings","text":"<ul> <li><code>File \u2192 Save Settings to File</code>: Saves the current configuration (processing parameters, recording setup, system settings, and active plugins) to an <code>*.ini</code> file.</li> <li><code>File \u2192 Load Settings from File</code>: Loads a previously saved settings file.</li> </ul>"},{"location":"functionality.html#saving-and-loading-view-layout","title":"Saving and loading view layout","text":"<ul> <li><code>View \u2192 Save Current Layout to File</code>: Saves the current window arrangement, visibility states, and panel sizes to an <code>*.ini</code> file.</li> <li><code>View \u2192 Load Layout from File</code>: Restores a previously saved layout file.</li> </ul> <p>Note</p> <p>All extension settings (including layout information, if provided by the extension) are currently stored in the settings file. This behavior may change in the future.</p>"},{"location":"plugin-axialpsfanalyzer.html","title":"Axial PSF Analyzer Extension","text":"<p>The Axial PSF Analyzer can be used to measure the axial resolution of an OCT system, defined as the Full Width at Half Maximum (FWHM) of the axial Point Spread Function (PSF).</p> <p>To perform the measurement, place a mirror as the sample and set the Region of Interest (ROI) so that it covers the horizontal line in the B-scan corresponding to the mirror surface. All A-scans within the selected ROI are averaged and displayed in the 1D plot on the right side. A Gaussian function is then fitted to this averaged A-scan to estimate the FWHM.</p> Axial PSF Analyzer Extension Interface"},{"location":"plugin-axialpsfanalyzer.html#how-to-use","title":"How to use","text":"<p>Note</p> <p>For a correct measurement, make sure to disable logarithmic scaling in the Processing tab of the OCTproZ sidebar. The Axial PSF Analyzer currently only supports Gaussian fits to linearly scaled A-scans.</p>"},{"location":"plugin-axialpsfanalyzer.html#user-interface","title":"User interface","text":"Parameter Description Buffer The buffer number from which you want to grab the frame. If you only use one buffer per volume, or if it does not matter which specific frame is used for the estimation, select All. This will grab the frame from the next available buffer. Frame The frame number within the buffer. Together with the buffer number, this allows you to select the specific frame within the OCT volume that should be grabbed. If you only use one frame per buffer, or if it does not matter which specific frame is used for the estimation, select 0. Auto fetch every nth buffer Automatically updates the OCT data every n-th buffer. Useful during live measurements, for example when moving the mirror through the entire axial imaging range to record the roll-off. Fit model currently not used Autoscaling If enabled, the A-scan plot with the Gaussian fit is automatically scaled so that the entire A-scan is visible."},{"location":"plugin-camera.html","title":"Camera Extension","text":"<p>The Camera Extension provides live view and controls for a camera. It allows users to place overlays on the camera image to indicate the OCT scan area. The position of the overlay is saved and automatically restored on restart.</p> Camera Extension Interface"},{"location":"plugin-camera.html#controls","title":"Controls","text":"Function Controls View Fitting Double-click to automatically fit the camera view to the window size Rotating SHIFT + mouse wheel Zooming CTRL + mouse wheel Snapshots CTRL + S Set Snapshot Save Location Right-click on the camera view -&gt; Set snapshot save location... OCT Scan Area Overlays Right-click on the camera view and select an overlay type (circle, line, rectangle, or polygon)"},{"location":"plugin-dispersionestimator.html","title":"Dispersion Estimator Extension","text":"<p>The Dispersion Estimator can be used to estimate suitable dispersion values \\( d_2 \\) and \\( d_3 \\) to improve axial resolution in the OCT images. This is done by automatically varying these dispersion parameters and calculating an A-scan quality metric. The resulting parameters that yield the maximal metric value are directly applied to the OCTproZ sidebar.</p> Dispersion Estimator Extension Interface"},{"location":"plugin-dispersionestimator.html#how-it-works","title":"How it works","text":"<p>The extension grabs a single raw frame and temporarily stores it. From this frame, a user-defined number of spectra are selected from the central region. OCT processing is then performed repeatedly on these spectra, while varying the dispersion coefficients to optimize the image quality. The optimization is done in two steps:</p> <ol> <li>In the first step, \\(d_3\\) is fixed at 0, while \\(d_2\\) is varied within a user-defined range and step size. For each value of \\(d_2\\), the corresponding A-scans are processed and evaluated using the selected image quality metric. The metric values from all A-scans are averaged to produce a single score for each \\(d_2\\), which is plotted in the result plot.</li> <li>In the second step, the \\(d_2\\) value that produced the best image quality is fixed, and \\(d_3\\) is varied in the same way. Again, the metric is evaluated and plotted.</li> </ol> <p>The resulting optimal values of \\(d_2\\) and \\(d_3\\) \u2014 those producing the highest quality metric \u2014 are displayed below the result plot and automatically transferred to the OCTproZ sidebar for immediate use.</p> <p>The approach of grabbing a single frame and using it for the entire optimization process allows the extension to be used even during live imaging with moving samples.</p>"},{"location":"plugin-dispersionestimator.html#how-to-use","title":"How to use","text":"<p>Note</p> <p>Perform k-linearization before attempting to numerically compensate dispersion!  The numerical dispersion compensation algorithm assumes k-linearized data and will only perform reliably under this condition.</p> <ol> <li> <p>Start OCTproZ processing.</p> </li> <li> <p>Set the region of interest. Typical settings are:  </p> <ul> <li>Buffer: All  </li> <li>Frame: 0  </li> <li>Use A-scans from the center: 40  </li> <li>Ignore the first n samples in A-scans: 20  </li> <li>Use linear instead of logarithmic A-scans: enabled  </li> </ul> </li> <li> <p>Configure the estimation options. These parameters need to be adjusted by trial and error, as they strongly depend on your OCT system and the sample structure visible in the OCT image.  </p> <ul> <li>In most cases, the image metrics Peak Value or Mean Sobel yield good results. For these metrics, the Threshold parameter is not used.  </li> <li>Select the Sample range for \\(d_2\\) and \\(d_3\\) such that the result plots show a clear curve with a single distinct peak. As a first guess you can start with -100 to 100 and 50 samples.</li> </ul> </li> <li> <p>Press Fetch data and estimate dispersion values.</p> </li> <li> <p>Check the result curves. Ideally, both \\(d_2\\) and \\(d_3\\) result plots should show a clear peak.     If this is not the case:  </p> <ul> <li>Adjust the sample ranges for \\(d_2\\) and/or \\(d_3\\).  </li> <li>Try a different image metric.  </li> <li>Consider increasing or decreasing Ignore the first n samples in A-scans.  </li> </ul> </li> <li> <p>Press Fetch data and estimate dispersion values again and repeat the process until a clear peak is visible in both plots.</p> </li> </ol>"},{"location":"plugin-dispersionestimator.html#image-metrics","title":"Image metrics","text":"Metric Description Sum Above Threshold Calculates the sum of all A-scan sample values that exceed a specified threshold. Higher values indicate more signal energy above the threshold. The Threshold parameter must be set. Samples Above Threshold Counts the number of A-scan samples that exceed a specified threshold. Inspired by Maciej Wojtkowski et al. (2004). The Threshold parameter must be set. Peak Value Returns the maximum value within the A-scan. This metric is independent of the Threshold parameter and works well when the signal has a distinct peak. Mean Sobel Calculates the sum of the absolute values of the axial gradient within each A-scan and averages these sums across all A-scans. This metric is independent of the Threshold parameter. It probably works well for structures with multiple layers."},{"location":"plugin-dispersionestimator.html#user-interface","title":"User interface","text":"Button Description Fetch data and estimate dispersion values When pressed, a single raw frame is grabbed from the current acquisition. For this to work, OCTproZ processing must be running. ... hide/show settings. Hide/show settings. This is useful when suitable parameters for the estimation process have already been found, and you only want to start the optimization without the extension GUI occupying too much space. Parameter Description Buffer The buffer number from which you want to grab the frame. If you only use one buffer per volume, or if it does not matter which specific frame is used for the estimation, select All. This will grab the frame from the next available buffer. Frame The frame number within the buffer. Together with the buffer number, this allows you to select the specific frame within the OCT volume that should be grabbed. If you only use one frame per buffer, or if it does not matter which specific frame is used for the estimation, select 0. Use n A-scans from the center Number of raw A-scans from the central region of a frame that should be used for the optimization. Ignore the first n samples in A-scans The number of samples at the beginning of each A-scan that should be excluded from the image metric calculation. This is useful if your OCT image contains artifacts, such as a DC component or autocorrelation artifacts at the top, and you want to ignore the upper part of the frame. Use linear instead of logarithmic A-scans If checked, the A-scans are not converted to a logarithmic scale after the FFT but are used in their linear representation for the optimization. In most cases, this yields better results. Image metric This is the metric calculated from the A-scans. A good metric will produce a smooth curve with a single distinct peak, representing the OCT image with the best axial resolution. Depending on your OCT system and the sample, different metrics may perform better. Threshold This parameter only applies to the image metrics Sum Above Threshold and Samples Above Threshold. It defines an A-scan intensity value (see plot A-Scans before and after dispersion compensation). Sample range for \\(d_2\\) Start and end values of the dispersion parameter \\(d_2\\)\u200b over which the optimization will search for the best image metric. Sample range for \\(d_3\\) Start and end values of the dispersion parameter \\(d_3\\)\u200b over which the optimization will search for the best image metric. Number of samples The number of \\(d_2\\) and \\(d_3\\)\u200b values to test within the defined sample range. This directly controls the step size between each sample."},{"location":"plugin-dispersionestimator.html#remote-control","title":"Remote control","text":"<p>You can start the estimation process remotely using the SocketStreamExtension by sending the command:</p> <pre><code>remote_plugin_control, Dispersion Estimator, startSingleFetch\n</code></pre>"},{"location":"plugin-imagestatistics.html","title":"Image Statistics Extension","text":"<p>The Image Statistics Extension displays a histogram of processed or raw OCT data during acquisition. A movable and resizable red rectangle in the preview window defines a region of interest. Zooming inside the preview window is possible with Ctrl + mouse wheel.</p> Image Statistics Extension Interface"},{"location":"plugin-peakdetector.html","title":"Peak Detector Extension","text":"<p>The Peak Detector displays the depth position of the highest intensity value within an averaged A-scan. The averaged A-scan is generated by averaging all A-scans within a user-defined Region of Interest (ROI) inside the current B-scan.</p> <p>This extension can be useful for simple distance measurement tasks or as a starting point for implementing a more advanced OCT peak detection plugin.</p> Peak Detector Extension Interface"},{"location":"plugin-peakdetector.html#user-interface","title":"User interface","text":"Parameter Description Buffer The buffer number from which you want to grab the frame. If you only use one buffer per volume, or if it does not matter which specific frame is used for the estimation, select All. This will grab the frame from the next available buffer. Frame The frame number within the buffer. Together with the buffer number, this allows you to select the specific frame within the OCT volume that should be grabbed. If you only use one frame per buffer, or if it does not matter which specific frame is used for the estimation, select 0. Minimum threshold Minimum A-scan intensity value that a sample must exceed to be considered a possible peak. Show If enabled, the position of the minimum threshold is shown in the A-scan plot below as a horizontal line. Autoscaling If enabled, the A-scan plot is automatically scaled so that the entire A-scan is visible."},{"location":"plugin-phaseextraction.html","title":"Phase Extraction Extension","text":"<p>The Phase Extraction Extension can be used to generate a resampling curve for k-linearization by extracting the phase of a calibration signal.</p> Phase Extraction Extension Interface"},{"location":"plugin-phaseextraction.html#how-it-works","title":"How it works","text":"<p>The plugin extracts the instantaneous phase of a calibration signal and uses it to generate a resampling curve for k-linearization. The processing steps are shown in the figure below. </p> Processing steps for generating a resampling curve for k-linearization. The instantaneous phase of an averaged autocorrelation signal is extracted using FFT, windowing, IFFT, and phase unwrapping. The inverse of the phase is the resampling curve. <p>First, one or multiple buffers of raw data are acquired and averaged. The averaged interferogram is Fourier-transformed, and a window is applied to isolate the calibration signal in the positive sideband. This windowed signal is then inverse Fourier-transformed, resulting in a complex signal. The phase is extracted using atan2 on the real and imaginary parts, then unwrapped to obtain the instantaneous phase. Finally, the instantaneous phase is inverted to get the resampling curve. The inversion can be thought of as swapping the axes or mirroring the phase signal along the 45\u00b0 diagonal.</p> <p>This method also works in the presence of a sample signal, as the averaging and windowing steps suppress most unwanted contributions, leaving only the calibration signal.</p> <p>Further details can be found in this conference paper.</p>"},{"location":"plugin-phaseextraction.html#how-to-use","title":"How to Use","text":"<ol> <li>Start OCTproZ processing.  </li> <li>Generate a calibration signal, for example by placing an optical window in front of the OCT reference mirror.  </li> <li>Open the Phase Extraction Extension and fetch raw data using the Fetch button.  </li> <li>Select A-scans for averaging (typically, selecting All works best, but you can also choose a specific range) and click on Average.  </li> <li>Select the calibration peak by setting the Start and End positions, then click on Analyze.  </li> <li>In the Results area, you can choose to ignore a number of samples at the beginning and end of your signal. This is useful if your interferogram is zero or close to zero at the edges. Then, click on Fit.  </li> <li>Use the result by either transferring the coefficients of the polynomial fit to the OCTproZ sidebar via click on Transfer coeffs, or by using the raw resampling curve. For the latter, click on Transfer curve to automatically apply the curve to OCTproZ processing, or click on Save curve to export the raw resampling curve as a CSV file.</li> </ol> <p>Note</p> <p>It is important that the calibration signal is free from phase distortions caused by dispersion imbalance. Otherwise, the extracted instantaneous phase will include both the dispersion-related phase and the phase caused by non-linear k-sampling, and the resulting resampling curve will not correctly linearize the data in k-space.</p> <p>A very simple way to generate a calibration signal that is free from dispersion imbalance is by placing a wedged optical window or an optical window with an anti-reflection coating on one side in front of the reference mirror. The light is mainly reflected back from the back surface of the optical window and the mirror. The back-reflected beams interfere with each other, generating an autocorrelation signal. The optical window should be thick enough so that any possible autocorrelation signal from the front and back surfaces of the window does not appear within the OCT imaging range, or at least does not overlap with the calibration signal. The distance between the back surface of the optical window and the mirror should be chosen such that the calibration signal appears somewhere in the bottom half of the B-scan.</p> <p>The following image illustrates the basic idea of how the autocorrelation signal is generated using the optical window\u2013mirror combination.</p> Generation of a calibration signal using an optical window\u2013mirror setup.  <p>A video demonstrating the use can be found here</p>"},{"location":"plugin-phaseextraction.html#demo-data-set","title":"Demo data set","text":"<p>A demo dataset can be found here. You can use it with the Virtual OCT System to test the Phase Extraction Extension offline. </p>"},{"location":"plugin-phaseextraction.html#user-interface","title":"User interface","text":"Parameter Description Start with first buffer of volume If checked, fetching starts from the first buffer of the volume. This should only be enabled if you have multiple buffers per volume and want to explicitly select a specific region for use in the Phase Extraction Extension. Buffers to fetch Number of buffers to fetch for averaging. Select A-scans for averaging Choose either All A-scans or specify a range using First and Last. Window averaged raw data If enabled, a Hann window will be applied over the entire averaged interferogram. Start Position (sample number) marking the beginning of the calibration peak. End Position (sample number) marking the end of the calibration peak. Windowing If enabled, a Hann window will be used instead of a rectangular window to isolate the selected calibration peak. ignore first Number of samples to ignore at the beginning of the interferogram during polynomial fitting. This is useful if the signal intensity is zero or close to zero at the start, to ensure a good polynomial fit. ignore last Number of samples to ignore at the end of the interferogram during polynomial fitting. c<sub>0</sub> to c<sub>3</sub> Coefficients of the polynomial fitted to the raw resampling curve. Button Description Fetch Start fetching the data. Cancel Cancel the fetching process. Average Start averaging the fetched data. Analyze Perform signal processing to generate the resampling curve. Fit Perform a polynomial fit on the raw resampling curve. This is usually done automatically, but if you change the values for ignore first or ignore last, you should run the fit again. Transfer coeffs Transfer the fitted coefficients \\(c_0\\) to \\(c_3\\) to OCTproZ. Transfer curve Transfer the raw resampling curve to OCTproZ. Save curve Save the resampling curve to a file."},{"location":"plugin-socketstream.html","title":"Socket Stream Extension","text":"<p>Socket Stream enables remote control of OCTproZ and allows streaming of processed data to another application, either on the same computer or on a different computer within the same network.  Supported communication protocols are: TCP/IP, WebSocket and IPC. IPC is implemented using Qt's <code>QLocalServer</code> and <code>QLocalSocket</code>, which use Unix Domain Sockets on Linux and Named Pipes on Windows.</p> <p>One example use case is transferring OCT data to a Python application for post-processing.</p> <p>Another example is remotely controlling a small, portable OCT system that either has no display or only a limited display, via a smartphone or tablet.</p> Socket Stream Extension Interface"},{"location":"plugin-socketstream.html#how-to-use","title":"How to use","text":"<ol> <li> <p>Create a custom client application (see Python examples here)    or use this WebSocket client that runs in a browser.</p> </li> <li> <p>Set the communication protocol, IP, and port (or the pipe name in case of IPC) in the Socket Stream extension.</p> </li> <li> <p>Click Start to start the server.</p> </li> <li> <p>Connect your client to the server using the configured IP and port.</p> </li> <li> <p>If you want to stream image data to your client, it is recommended to connect a second client:    Use one client for commands only (activate with the command <code>enable_command_only_mode</code>)    and a second client for image streaming only.</p> </li> <li> <p>Use commands (see table below).</p> </li> </ol>"},{"location":"plugin-socketstream.html#user-interface","title":"User interface","text":"Parameter Description Mode Selects the communication protocol: TCP/IP, IPC (Local Sockets), or WebSocket. Pipe name Name of the IPC pipe (used only in IPC mode). IP IP address of the server (used in TCP/IP and WebSocket modes). Port Port number of the server (used in TCP/IP and WebSocket modes). Auto connect on startup Automatically starts the server when the extension is activated. Include header to data transfer Adds a 13-byte header to every data packet containing meta information like image size and bit depth."},{"location":"plugin-socketstream.html#data-header","title":"Data header","text":"<p>If enabled, each transmitted data packet starts with a 13-byte header containing meta information about the OCT image. This allows the client to correctly interpret the incoming data. </p> <p>The header consists of:</p> Field Type (Size) Description Magic Number unsigned int (4 bytes) Fixed value <code>299792458</code> (decimal) for synchronization Data Size unsigned int (4 bytes) Total size of image data in bytes Frame Width unsigned short (2 bytes) Number of pixels per A-scan Frame Height unsigned short (2 bytes) Number of A-scans per frame Bit Depth unsigned char (1 byte) Bits per pixel (e.g., 8 or 16)"},{"location":"plugin-socketstream.html#available-remote-commands","title":"Available remote commands","text":"Command Description <code>remote_start</code> Starts the OCT processing. <code>remote_stop</code> Stops the OCT processing. <code>remote_record</code> Starts recording the OCT data. <code>load_settings:&lt;path_to_settings_file&gt;</code> Loads settings from a specified file. Replace <code>&lt;path_to_settings_file&gt;</code> with the actual file path. <code>save_settings:&lt;path_to_settings_file&gt;</code> Saves current settings to a specified file. Replace <code>&lt;path_to_settings_file&gt;</code> with the desired file path. <code>set_disp_coeff:&lt;coeff1&gt;:&lt;coeff2&gt;:&lt;coeff3&gt;:&lt;coeff4&gt;</code> Sets dispersion coefficients. Each value can be a double or <code>nullptr</code> / <code>null</code>. <code>set_grayscale_conversion:&lt;enable_log_scaling&gt;:&lt;max&gt;:&lt;min&gt;:&lt;multiplicator&gt;:&lt;offset&gt;</code> Configures grayscale conversion. Parameters: <code>enable_log_scaling</code> (<code>true</code>/<code>1</code> or <code>false</code>/<code>0</code>), the rest are double values or <code>nan</code> / <code>null</code> / <code>nullptr</code>. <code>remote_plugin_control,&lt;PluginName&gt;,&lt;Command&gt;</code> Sends a command to another OCTproZ plugin. Example: <code>remote_plugin_control, Dispersion Estimator, startSingleFetch</code> <code>enable_command_only_mode</code> Switches client connection to command-only mode (no image streaming). <code>disable_command_only_mode</code> Switches client connection back to command + data streaming mode. <code>ping</code> Health-check command \u2014 server replies with <code>pong</code>."},{"location":"plugins.html","title":"Plugins","text":"<p>OCTproZ supports two distinct types of plugins:</p> Plugin Type Purpose Acquisition Systems Acquire raw data from OCT hardware or files Extensions Add new features and functionality to OCTproZ"},{"location":"plugins.html#available-plugins","title":"Available plugins","text":"<p>Acquisition Systems:</p> Name Description PhytoOCT A portable and low-cost OCT system. Virtual OCT System Can be used to load already acquired OCT raw data from the disk <p>Extensions:</p> Name Description Axial PSF Analyzer Measuring the FWHM of the axial point spread function. Camera Displays live view from a webcam. Demo Extension This demo extension is for developers. It has no useful functionality, but the code can be used as a template for developing custom extensions. Dispersion Estimator Helps determining suitable dispersion parameters d2 and d3 for better axial resolution. Image Statistics Displays useful image statistics, such as a histogram, in real time of currently acquired B-scans. Peak Detector Detects and displays the position of the highest peak in an A-scan. Phase Extraction Can be used to determine a suitable resampling curve for k-linearization. Signal Monitor Displays signal intensity. Useful during optical alignment for maximizing intensity on detector. Socket Stream Controlling OCTproZ remotely and streaming OCT data via TCP/IP, Websocket, IPC."},{"location":"plugins.html#custom-plugin-development","title":"Custom plugin development","text":"<p>Have a look at the plugin developer guide. </p>"},{"location":"processing.html","title":"Processing Pipeline","text":"<p>The OCT signal processing is entirely performed on the GPU. The spectral interferograms acquired by the OCT system are transferred to RAM until a user-defined number of B-scans is collected. This raw data batch is then copied to GPU memory for processing and display. Finally, the processed data is copied back to RAM, where it can be used for further analysis by plugins or saved to disk.</p> <p>The following image shows the processing pipeline. While most steps can be enabled or disabled by the user, data conversion, IFFT, and truncation are always active.</p> OCTproZ processing pipeline"},{"location":"processing.html#processing-steps","title":"Processing Steps","text":""},{"location":"processing.html#data-conversion","title":"Data conversion","text":"<p>The first step of the OCT processing pipeline converts the incoming raw data, that may have a bit depth between 8 bit and 32 bit, to a single-precision, floating-point complex data type with a bit depth of 32 bit. This ensures that the processing pipeline can be executed for a variety of different input data types. Furthermore, a bit shift operation can be applied during the conversion process if necessary. Some digitizers, that are commonly used for swept-source OCT (SS-OCT), can be configured to use 16-bit integers to store 12-bit sample values in the most significant bits (e.g. ATS9373, Alazar Technologies Inc.). To extract the actual 12-bit value a right-shift by 4, which is equal to a division by 16, needs to be applied to every 16-bit integer.</p>"},{"location":"processing.html#dc-background-removal","title":"DC background removal","text":"<p>The DC component of the OCT signal is usually visible at the top of each B-scan as a bright line. To remove this DC component from each raw spectrum  \\( I_{\\mathrm{raw}}[m] \\), a rolling average with a user-adjustable window size \\( W \\) can be computed and subtracted from the raw signal. Ignoring boundary checks, the DC\u2011corrected signal is calculated by</p> \\[     I_{\\mathrm{ac}}[m] = I_{\\mathrm{raw}}[m] - \\frac{1}{2W} \\sum_{n=m-W+1}^{m+W} I_{\\mathrm{raw}}[n]. \\] <p>In cases where the DC component does not vary significantly over time, the fixed-pattern noise removal step can also eliminate it. </p>"},{"location":"processing.html#k-linearization","title":"k-linearization","text":"<p>To convert the acquired raw OCT data into a depth profile, an inverse Fourier transform can be used, which relates wavenumber k to physical distance. For optimal axial resolution, the raw data must be uniformly sampled in k-space. However, depending on the used hardware setup, the acquired spectral fringe pattern is usually not linear in k. In swept-source OCT, the wavenumber-time characteristics of the light source are often non-linear. In spectrometer-based OCT systems, the exact pixel position to wavenumber relationship depends on the optical elements of the spectrometer. There are hardware based approaches that enable a k-linear sampling like using a k-clock for non-linear temporal sampling of the raw signal in swept-source OCT or using special k-linear spectrometer designs.</p> <p>Alternatively, there are software-based approaches to generate a signal with a k-space uniform sampling by resampling the data such that the data points are evenly distributed in k-space. This process is known as k-linearization. For the software-based approach in OCTproZ, a user-defined resampling curve \\( r[m] \\) can be specified by providing the coefficients of a third-order polynomial. The resampling curve is a lookup table that assigns every index \\( m \\) of the raw data array \\( I_{\\mathrm{raw}}[m] \\) an index \\( m^\\prime \\), i.e. \\( m^\\prime = r[m] \\). To obtain a k-linearized raw data array \\( I_{\\mathrm{k}}[m] \\), the sample value at the index \\( m^\\prime \\) needs to be interpolated and remapped to the array position with index \\( m \\). The simplest way to do this is by using linear interpolation:</p> \\[     I_{\\mathrm{k}}[m]      = I_{\\mathrm{raw}}[\\lfloor m^\\prime \\rfloor]      + \\bigl(m^\\prime - \\lfloor m^\\prime \\rfloor \\bigr)        \\bigl(I_{\\mathrm{raw}}[\\lfloor m^\\prime \\rfloor+1] - I_{\\mathrm{raw}}[\\lfloor m^\\prime \\rfloor]\\bigr) \\] <p>\\( \\lfloor x \\rfloor \\) denotes the floor function that takes as input \\( x \\), a real number, and gives as output the greatest integer less than or equal to \\( x \\).</p> <p>Note</p> <p>The polynomial used for the resampling curve has the form: r(m) = c<sub>0</sub> + (c<sub>1</sub>/N)m + (c<sub>2</sub>/N<sup>2</sup>)m<sup>2</sup> + (c<sub>3</sub>/N<sup>3</sup>)m<sup>3</sup> where N is the number of samples per raw A-scan - 1.</p> <p>Note</p> <p>A custom resampling curve (that does not need to be a polynomial fit) can be loaded by clicking on <code>Extras \u2192 Resampling curve for k-linearization \u2192 Load custom curve from file...</code> The structure of the csv file with the curve data should be the same as the structure of the csv file that you get by right clicking on the resampling curve plot in the sidebar and saving the plot as csv file.</p> <p>Note</p> <p>You can use the PhaseExtractionExtension for easy resampling curve determination.</p> <p>Currently, three interpolation methods are available in OCTproZ: Linear, Cubic Spline (Catmull-Rom Spline), and Lanczos. These methods represent a trade-off between speed and accuracy, with Linear being the fastest and Lanczos being the most accurate. The figure below shows typical interpolation artifacts that can be seen when using the different interpolation methods:</p> Image artifacts of different interpolation methods for k-linearization indicated by red arrows"},{"location":"processing.html#dispersion-compensation","title":"Dispersion compensation","text":"<p>Differences in the dispersive media lengths in the sample and reference arms of an OCT system introduce a wavenumber\u2011dependent phase shift on the raw signal that degrades axial resolution of the processed OCT images. While hardware\u2011based methods (e.g. prism pairs used as variable\u2011thickness windows) can physically balance dispersion mismatch, numerical dispersion compensation offers a flexible alternative, especially in cases where the mismatch is mainly caused by the sample and not only by the optical setup itself.</p> <p>In numerical dispersion compensation, the raw signal \\( I_{\\mathrm{raw}}[m] \\) is corrected by multiplying it with a phase term that cancels the dispersion\u2011induced phase shift:</p> \\[     I_{\\mathrm{comp}}[m] = I_{\\mathrm{raw}}[m] \\cdot e^{-i\\,\\theta\\bigl(k\\bigr)}, \\] <p>where \\( \\theta(k) \\) is a user\u2011defined phase function. Expressing the phase term in its real and imaginary parts as</p> \\[     e^{-i\\,\\theta\\bigl(k\\bigr)} = \\cos\\bigl(\\theta(k)\\bigr) - i\\,\\sin\\bigl(\\theta(k)\\bigr) \\] <p>and noting that the imaginary part of \\( I_{\\mathrm{raw}}[m] \\) is zero, the multiplication simplifies to</p> \\[     \\begin{aligned}         \\mathrm{Re}\\{ I_{\\mathrm{comp}}[m] \\} &amp;= I_{\\mathrm{raw}}[m] \\cdot \\cos\\bigl(\\theta(k)\\bigr),\\\\         \\mathrm{Im}\\{ I_{\\mathrm{comp}}[m] \\} &amp;= -I_{\\mathrm{raw}}[m] \\cdot \\sin\\bigl(\\theta(k)\\bigr).     \\end{aligned} \\] <p>This simplified calculation avoids performing a full complex multiplication. This appraoch is slightly different from the one described by Maciej Wojtkowski et al. (2004). In their method, the Hilbert transform is used to generate the imaginary part of the raw signal, and then a full complex multiplication is performed. Both approaches result in identical OCT data.</p> <p>The phase function \\( \\theta(k) \\) is implemented as a third\u2011order polynomial with coefficients \\( d_0, d_1, d_2, d_3 \\), which can be set in the GUI. \\( d_0 \\) does not change the resulting OCT images at all; \\( d_1 \\) can be used to shift the OCT image in axial direction without altering the axial resolution. Only \\( d_2 \\) and \\( d_3 \\) are responsible for the actual dispersion compensation that can improve axial resolution. </p> <p>In many cases, it is possible to find good values for \\( d_2 \\) and \\( d_3 \\) by manually varying them  until the resulting image shows the best axial resolution. However, it is also possible to use the dispersion estimator extension to obtain suitable coefficient values by optimizing an A-scan quality metric. </p>"},{"location":"processing.html#windowing","title":"Windowing","text":"<p>The raw data is multiplied by a window function, which sets the signal to zero outside of a predefined interval. This reduces side lobes in the resulting signal after IFFT. The GUI allows to choose between different window functions (Gaussian, Hanning, Sine, Lanczos and Rectangular window) and to set their width and center position.</p>"},{"location":"processing.html#inverse-fast-fourier-transform-ifft","title":"Inverse Fast Fourier Transform (IFFT)","text":"<p>The inverse Fourier transform is the essential processing step to calculate the depth profile from a spectral interferogram. The IFFT output is normalized by dividing each sample by the total number of samples.</p>"},{"location":"processing.html#fixed-pattern-noise-removal","title":"Fixed-pattern noise removal","text":"<p>Fixed pattern noise refers to structural artifacts in OCT images that appear as fixed horizontal lines. These artifacts are caused, for example, by variations in pixel response in the CCD camera in spectrometer based OCT systems or spurious etalons within the optical OCT setup. A common approach to reduce fixed pattern noise is to acquire a reference signal in absence of a sample and subtract it from all subsequent recordings. In OCTproZ, the minimum-variance mean-line subtraction method that was described by Moon et al. (2010) can be used. This approach does not require an additional reference recording and can be applied continuously such that fixed pattern noise due spectral intensity variation of the source is reduced as well.</p>"},{"location":"processing.html#truncate","title":"Truncate","text":"<p>This step removes the mirror image on the opposite side of zero pathlength by cropping half of the processed OCT data. The mirror image is sometimes referred to as mirror artifact or complex conjugate artifact. It originates from the fact that the inverse Fourier transform is applied to a real-valued signal which results in a conjugate symmetric signal (i.e. the positive and negative distances are complex conjugates of each other).</p>"},{"location":"processing.html#logarithm-and-dynamic-range-adjustment","title":"Logarithm and dynamic range adjustment","text":"<p>For better visualization of OCT data, some form of dynamic range compression is usually used because the smallest and largest signals can differ by several orders of magnitude. The most common method, which is also used in OCTproZ, is simply to take the logarithm of the signal after IFFT:</p> \\[ i[z] = 20 \\, \\log_{10}\\!\\left|\\mathcal{F}^{-1}\\{I_k[m]\\}\\right| \\] <p>In addition, dynamic range adjustment is performed to enable the user to set minimum and maximum values (in dB) that should be displayed:</p> \\[ i_{\\text{adj}}[z] = \\text{coeff} \\left( \\frac{i[z]- \\text{min}}{\\text{max} - \\text{min}} + \\text{addend} \\right), \\] <p>The parameters coeff, min, max, and addend can be set by the user. Usually, min and max are chosen so that the noise floor in the OCT images appears quite dark and the actual signal of interest appears bright. Coeff can be used to adjust the contrast of the image, and addend can be used to adjust the brightness. Typically, these values are set to coeff = 1 and addend = 0.</p>"},{"location":"processing.html#backward-scan-correction","title":"Backward scan correction","text":"<p>To increase frame rate, a bidirectional scanning scheme can be used. However, this means that every other frame is flipped. The backward scan correction step unflips these frames.</p> Bidirectional scanning scheme and the effect of backward scan correction on the en face view <p>The image above shows the effect of the backward scan correction on the en face view of an OCT volume that was acquired using a bidirectional scanning scheme. A piece of wood with a laser burned hole was used as sample. Left: Spot path on sample when a bidirectional scanning scheme is applied. Middle: En face view with enabled backward scan correction. Right: En face view when backward scan correction is disabled.</p>"},{"location":"processing.html#sinusoidal-scan-correction","title":"Sinusoidal scan correction","text":"<p>A resonant scanner can be used for high-speed OCT systems. Due to the sinusoidal scan motion, the resulting images are distorted. This processing step uses linear interpolation to unstretch this sinusoidal distortion. The figure below shows the effect of this processing step.</p> En face view of a grid structure acquired with sinusoidal scanning. Left: sinusoidal scann correction not applied, distortions visible. Right: en face view after applying sinusoidal scan correction,"},{"location":"processing.html#post-processing-background-subtraction","title":"Post-processing background subtraction","text":"<p>In some cases, residual horizontal lines may persist even after DC background removal and fixed-pattern noise correction. Additionally, other types of artifacts, such as axial intensity gradients, can still be present. This post-processing background subtraction step can be used to reduce these artifacts.</p> <p>A background A-scan \\( i_{\\text{bg}}[z] \\) is first computed by averaging all A-scans from a separate background recording. During processing, each A-scan \\( i[z] \\) is then corrected by subtracting a scaled and offset version of this background:</p> \\[ i_{\\text{corr}}[z] = i[z] - (w \\cdot i_{\\text{bg}}[z] + o) \\] <p>where \\( w \\) is a user-defined weight factor and \\( o \\) is a user-defined offset.</p>"},{"location":"processing.html#final-data-conversion-and-export","title":"Final data conversion and export","text":"<p>Before the processed OCT data is transferred to CPU memory \u2014 either for saving to disk or for use by other plugins \u2014 it is converted back to the original raw data bit depth. During this conversion, out-of-range values are clamped, and the data is scaled to the entire value range of the target bit depth (e.g., 0\u2013255 for 8-bit, 0\u201365535 for 16-bit).</p> <p>Alternatively, for saving to disk, this conversion can be disabled. In this case, the internal 32-bit floating-point data is transferred to CPU memory and saved directly to disk without any additional scaling or clamping (except for the scaling already applied in the Logarithm and dynamic range adjustment step). Note that this option only affects saving to disk \u2014 processed data streamed to plugins is always converted to the original raw data bit depth.</p>"},{"location":"processing.html#effect-of-single-processing-steps","title":"Effect of single processing steps","text":"<p>To illustrate the effect of single processing steps, B-scans of an OCT phantom (APL-OP01, Arden Photonics, UK) were acquired with a custom made SS-OCT system without k-klocking and with a slight dispersion imbalance. The acquired raw data was processed multiple times, each time with a different processing step disabled:</p> The B-scans show a test pattern of an OCT phantom (APL-OP01, Arden Photonics, UK). Below each B-scan is an enlarged view of a corresponding area framed in red within the B-scan. a) The full processing pipeline is enabled. b) k linearization is disabled (all other steps are enabled). c) Dispersion compensation is disabled (all other steps are enabled). d) Windowing is disabled (all other steps are enabled). e) Fixed-pattern noise removal is disabled (all other steps are enabled). The red arrows point to horizontal structural artifacts that are visible if fixed-pattern noise removal is disabled."},{"location":"quickstart.html","title":"Quick Start Guide","text":"<p>This section shows you how to load an OCT raw dataset with the Virtual OCT System Extension that is provided with OCTproZ. For testing purposes you can download a test data set from here.</p>"},{"location":"quickstart.html#1-open-virtual-oct-system","title":"1. Open Virtual OCT System","text":"<p>Click on File \u2192 Open System</p> <p></p> <p>The system manager opens in a new window. Select \"Virtual OCT System\" and click on \"Select\"</p> <p></p>"},{"location":"quickstart.html#2-set-virtual-oct-system-settings","title":"2. Set Virtual OCT System settings","text":"<p>Click on File \u2192 System Settings</p> <p></p> <p>The system settings window opens. Click on Select file and select the OCT raw data file you want to open. Enter the parameters in the settings window according the dimensions of your raw data (bit depth per sample, samples per line,...). For more information on the individual parameters, click on the question mark in the upper right corner and then on the input field you would like to learn more about.</p> <p></p>"},{"location":"quickstart.html#3-set-processing-parameters-in-sidebar","title":"3. Set processing parameters in sidebar","text":"<p>Enter suitable processing parameters in the sidebar. The white curves in the k-linearization, dispersion compensation and windowing plots are reference curves that indicate how a curve would look like that does not effect the processing result at all. In other words: If your curve looks exactly as the white curve then the processing result will not change if this particular processing step is deactivated. For more information on processing, see the processing pipeline section.</p> <p></p>"},{"location":"quickstart.html#4-start-the-processing","title":"4. Start the processing","text":"<p>Click on the \"Start\" button in the top left of the sidebar.</p> <p></p>"},{"location":"quickstart.html#5-adjust-display-settings","title":"5. Adjust display settings","text":"<p>Hover your mouse over one of the output windows and a control panel will appear that you can use to adjust the display settings.</p> <p></p>"},{"location":"troubleshooting.html","title":"Troubleshooting","text":""},{"location":"troubleshooting.html#no-visual-output-b-scan-en-face-view-and-volume-windows-are-black-after-clicking-start-button","title":"No visual output. B-scan, En Face View and Volume windows are black after clicking start button","text":"<ul> <li>Check if you have a CUDA compatible GPU.</li> <li>Check if your monitor cable is connected to the GPU. If your monitor is connected to the motherboard, the processing will still run on the GPU but there will be no visual output in the OpenGL windows.</li> <li>Check if you have the right processing settings. With some settings, the complete output is set to 0 and the output windows remain black. For example if all k-linearization coefficients are 0, the output will be 0. If the windowing fill factor is 0, the output will be 0. If the grayscale conversion multiplicator is 0, the output will be 0.</li> <li>Check if the stretch parameters are greater than 0 in your display settings. See step 5 in the quick start guide</li> <li>If you are using Windows Remote Desktop, OpenGL may not work properly which can cause black output windows.</li> </ul>"},{"location":"troubleshooting.html#crash-right-after-clicking-start-button-and-using-virtual-oct-system","title":"Crash right after clicking start button and using Virtual OCT System","text":"<ul> <li>Maybe the size of the OCT data buffer is too large and you are running out of GPU memory. Try reducing the buffer size by reducing B-scans per buffer in the Virtual OCT System settings.</li> </ul>"},{"location":"visualization.html","title":"Visualization","text":"<p>For live visualization of the processed data in 2D and 3D, the user has access to three different output windows: B-scan, en face view and volume. B-scan and en face view are orthogonal cross-sectional slices of the volume, which can be maximum intensity projections or averaged layers of a user-defined amount of layers of the volume. For easier orientation, red marker lines can be overlaid to indicate the current B-scan slice position within the en face view and vice versa.</p> <p>The interactive volume viewer displays acquired OCT volumes without cropping or downsampling in real time. As soon as one batch of data is processed, the corresponding part of the volume is updated and rendered. In order to avoid unnecessary data transfer to host memory, CUDA-OpenGL interoperability is used which allows the processed data to remain in GPU memory for visualization.</p>"},{"location":"visualization.html#volume-rendering","title":"Volume rendering","text":"<p>Here are some example images showcasing an OCT volume of a fingernail rendered using the implemented volume rendering techniques:</p> <p></p>"}]}